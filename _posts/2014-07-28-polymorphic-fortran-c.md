---
layout: post
title: Polymorphic Fortran & C
date: 2014-07-28 22:30:31.000000000 +09:00
type: post
published: true
status: publish
categories: []
tags:
- c
- fortran
- gpl
- oop
- python
- automation
---
<h1>포트란 함수 오버로딩과 중복</h1>
앞서 [포트란 함수 오버로딩에 관한 글]({% post_url 2014-07-12-fortran_function_overloading %})을 올렸습니다. 포트란 모듈과 인터페이스를 이용하면 서로 다른 자료형을 인자로 받는 함수나 서브루틴이라도 같은 이름으로 사용할 수가 있었습니다. 그런데, 동적 자료형을 지원하는 언어와 달리, 포트란에서는 자료형별로 서브루틴들을 따로 만든 후에 같은 이름으로 호출하였습니다. 동적 자료형 언어에서는 함수 자체를 한 번만 작성하면 되지요. 여기에서 포트란 코드 작성에 중복이 발생하게 됩니다. 이러한 중복을 제거하기 위해 파이썬으로 만든 스크립트가 polyfc (Polymorphic Fortran &amp; C)입니다. 예전에 <a href="https://github.com/drewmccormack/forpedo">Forpedo</a>에서 아이디어를 얻었는데, Forpedo를 사용하려니 좀 복잡해서 Python 연습도 할 겸 [gpl]({% post_url 2014-07-26-geophysical-prospecting-library %})용으로 만들었습니다.
<h1>예제</h1>
<p>이해하기 쉽게 예제를 살펴보겠습니다. 배열의 내용을 출력하는 서브루틴을 작성하려고 합니다. 배열은 integer, real, real(kind=8), complex, complex(kind=8) 다섯 종류의 자료형을 지원하려고 합니다. 그럼 서브루틴을 자료형에 따라 총 5개를 작성해야 하는데, 선언부만 다르고 나머지는 동일하거나 거의 비슷하게 됩니다. 그래서 일종의 템플릿 서브루틴을 만들고, 필요한 부분만 바꿔가며 서브루틴을 복제하려고 합니다. 그러면 거의 비슷한 코드를 중복해서 작성하는 수고를 덜 수 있겠죠. 아래는 polyfc에 입력으로 들어가는 템플릿 파일입니다.</p>
```fortran
module polyfc_example

!@interface print_array
contains
!@template print_array ifdcz
    subroutine print_array_<name>(arr)
    <type>,intent(in):: arr(:)
    integer i
    do i=1,size(arr)
        print*, i, arr(i)
    enddo
    end subroutine
!@end
end module
```
포트란 주석을 이용하여 인터페이스가 들어갈 부분과 템플릿 부분을 표시하고, 자료형에 따라 바뀌어야 하는 부분은 `<name>`, `<type>`으로 표시하였습니다. 이 외에 필요할 경우 `<kind>`와 `<esize>`도 지원합니다. 바뀌며 들어가는 부분은 다음 표를 보면 알 수 있습니다.

<table>
<thead>
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:left;">Fortran type</th>
<th style="text-align:left;">C type</th>
<th style="text-align:left;">Fotran kind</th>
<th style="text-align:center;">esize</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">i</td>
<td style="text-align:left;">integer</td>
<td style="text-align:left;">int</td>
<td style="text-align:left;">(kind=4)</td>
<td style="text-align:center;">4</td>
</tr>
<tr>
<td style="text-align:center;">f</td>
<td style="text-align:left;">real</td>
<td style="text-align:left;">float</td>
<td style="text-align:left;">(kind=4)</td>
<td style="text-align:center;">4</td>
</tr>
<tr>
<td style="text-align:center;">d</td>
<td style="text-align:left;">real(kind=8)</td>
<td style="text-align:left;">double</td>
<td style="text-align:left;">(kind=8)</td>
<td style="text-align:center;">8</td>
</tr>
<tr>
<td style="text-align:center;">c</td>
<td style="text-align:left;">complex</td>
<td style="text-align:left;">float complex</td>
<td style="text-align:left;">(kind=4)</td>
<td style="text-align:center;">8</td>
</tr>
<tr>
<td style="text-align:center;">z</td>
<td style="text-align:left;">complex(kind=8)</td>
<td style="text-align:left;">double complex</td>
<td style="text-align:left;">(kind=8)</td>
<td style="text-align:center;">16</td>
</tr>
<tr>
<td style="text-align:center;">b</td>
<td style="text-align:left;">logical</td>
<td style="text-align:left;">(not supported)</td>
<td style="text-align:left;">(kind=4)</td>
<td style="text-align:center;">4</td>
</tr>
<tr>
<td style="text-align:center;">s</td>
<td style="text-align:left;">character(len=*)</td>
<td style="text-align:left;">char</td>
<td style="text-align:left;">(len=*)</td>
<td style="text-align:center;">1</td>
</tr>
</tbody>
</table>

<p>그래서 <code>polyfc input.f90 > output.f90</code>과 같이 실행했을 때 얻게 되는 파일은 다음과 같습니다.</p>

```fortran
! This file was generated from pfc.example.f90 by Polyfc at Mon Jul 28 22:12:32 2014.
! Do not edit this file directly.

module polyfc_example

    interface print_array
        module procedure print_array_i
        module procedure print_array_f
        module procedure print_array_d
        module procedure print_array_c
        module procedure print_array_z
    end interface print_array

contains

    subroutine print_array_i(arr)
    integer,intent(in):: arr(:)
    integer i
    do i=1,size(arr)
        print*, i, arr(i)
    enddo
    end subroutine

    subroutine print_array_f(arr)
    real,intent(in):: arr(:)
    integer i
    do i=1,size(arr)
        print*, i, arr(i)
    enddo
    end subroutine

    subroutine print_array_d(arr)
    real(kind=8),intent(in):: arr(:)
    integer i
    do i=1,size(arr)
        print*, i, arr(i)
    enddo
    end subroutine

    subroutine print_array_c(arr)
    complex,intent(in):: arr(:)
    integer i
    do i=1,size(arr)
        print*, i, arr(i)
    enddo
    end subroutine

    subroutine print_array_z(arr)
    complex(kind=8),intent(in):: arr(:)
    integer i
    do i=1,size(arr)
        print*, i, arr(i)
    enddo
    end subroutine

end module
```

<p>자동으로 작성하면 손으로 복사했을 경우 생길 수 있는 오류도 피할 수 있겠죠. 단, 코드에 버그가 있을 때에는 output 파일에서 버그가 있는 곳을 찾아 input 파일의 해당 위치를 고쳐줘야 합니다.</p>
참고로, polyfc 이름이 의미하듯, C도 지원합니다. 단, C에서는 `<name>`과 `<type>`만 지원합니다. 물론 인터페이스도 지원하지 않습니다. C에서는 아래와 같은 방식으로 사용 가능합니다.

```c
//@template ifdczbs
void abc_<name>(<type> def)
{
    ...
}
//@end
```
